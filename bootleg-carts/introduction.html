<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Bootleg Carts - gbadoc</title>


        <!-- Custom HTML head -->
        <!-- Matomo tracking code -->
        <script>
          var _paq = window._paq = window._paq || [];
          /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
          _paq.push(['trackPageView']);
          _paq.push(['enableLinkTracking']);
          (function() {
            var u="//stats.gbdev.io/";
            _paq.push(['setTrackerUrl', u+'matomo.php']);
            _paq.push(['setSiteId', '3']);
            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
            g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
          })();
        </script>
        <!-- End Matomo Code -->

        <meta name="description" content="Documents the workings of the Game Boy Advance hardware">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">gbadoc</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bootleg-carts"><a class="header" href="#bootleg-carts">Bootleg Carts</a></h1>
<p>Bootleg carts, sometimes called repro carts, are illegal game carts sold from China.  At the time of
writing, some members of the GBADev community have purchased them for around $5/cart.</p>
<p>From discussion with store owners in China, these carts cannot be ordered blank -- they are created
with copywritted games already on them (usually the popular games, Pokemon, Mario, etc).</p>
<p>However, these carts <em>can</em> be cleaned and overwritten with homebrew games.</p>
<p>This guide will describe how to develop games for bootleg carts.</p>
<ol>
<li><a href="#size-of-carts">Size of Carts</a></li>
<li><a href="#removing-label">Removing Label</a></li>
<li><a href="#flashing-cart">Flashing Cart</a></li>
<li><a href="#batteryless-saving">Batteryless Saving</a></li>
<li><a href="#hardware-used-in-carts">Hardware Used in Carts</a></li>
<li><a href="#swapping-of-d0d1">Swapping of D0/D1</a></li>
<li><a href="#understanding-commands">Understanding Commands</a></li>
<li><a href="#querying-for-information">Querying for Information</a></li>
<li><a href="#detecting-if-d0d1-are-swapped">Detecting if D0/D1 are Swapped</a></li>
<li><a href="#understanding-region-layout">Understanding Region Layout</a></li>
<li><a href="#erasing-a-sector">Erasing a Sector</a></li>
<li><a href="#saving-data">Saving Data</a></li>
<li><a href="#final-thoughts">Final Thoughts</a></li>
</ol>
<h2 id="size-of-carts"><a class="header" href="#size-of-carts">Size of Carts</a></h2>
<p>The carts typically range in size from 4MB to 32MB, with 16MB being the most common.</p>
<p>If your game requires a lot of storage space, then you will be more restricted in which carts you
can buy.</p>
<p>For example, <em>Pokemon</em> games come on 16MB carts, and <em>Kingdom of Hearts - Chain of Memories</em> is
32MB.</p>
<h2 id="removing-label"><a class="header" href="#removing-label">Removing Label</a></h2>
<p><img src="images/label.jpg" alt="Label Removal - Before and After" /></p>
<p>The carts will arrive with illegal content and label.  Some carts and cases arrive with scuff marks
as well.</p>
<p>To remove the label, first take the cart apart.  You will need a Y0 screw bit, sometimes called a
gamebit.  The <a href="https://www.ifixit.com/Store/Tools/Moray-Driver-Kit/IF145-475">iFixit Moray Driver
Kit</a> contains one, but they can be
found in lots of places.</p>
<p><img src="images/back.jpg" alt="Back of Cart" /></p>
<p>Some products that work with removing labels are <a href="https://googone.com/">Goo Gone</a> and
<a href="https://www.wd40.com/">WD-40</a>.</p>
<p>Spray a little bit of the liquid on the label, and wait for it to soak in (Goo Gone takes about
5min).  Then scrap off the label, and wash the plastic with soap and water.</p>
<p><img src="images/label-removal.jpg" alt="Label Removal" /></p>
<h2 id="flashing-cart"><a class="header" href="#flashing-cart">Flashing Cart</a></h2>
<p><img src="images/flashers.jpg" alt="Flashing Hardware" /></p>
<p>You will need a device to connect the cart to your computer in order to overwrite the contents of
the cart with your game.</p>
<p>Here are some known flashers at the time of writing:</p>
<ul>
<li><a href="https://shop.insidegadgets.com/product/gbxcart-rw/">GBxCart RW</a></li>
<li><a href="https://bennvenn.myshopify.com/collections/cart-flasher-dumper-reader-writer">Joey Jr</a></li>
<li><a href="https://www.epilogue.co/">GB Operator</a></li>
</ul>
<p>I personally like GBxCart RW the best because it works on Mac OSX, runs from the command line, and
is <a href="https://github.com/lesserkuma/FlashGBX">open source</a>.  To flash your game using GBxCart RW,
after installing FlashGBX on your system, you run:</p>
<pre><code class="language-bash">python3 -m FlashGBX --mode agb --action flash-rom MyGame.gba
</code></pre>
<p>Joey Jr works on Windows and doesn't require any installation, since the cart will show up as an
external drive.  You simply drag your game on to the drive in Windows Explorer (or <code>copy</code> from the
command line).</p>
<p>GB Operator has a user interface for playing games off of carts, and is more polished.  Writing
games to flash carts is just one feature.</p>
<p>Your needs may vary, and features may change over time.  Buy the best one that works for you, or
buy all of them :-).  They're pretty cheap.</p>
<h2 id="batteryless-saving"><a class="header" href="#batteryless-saving">Batteryless Saving</a></h2>
<p>The flashers work because the cart ROMs can be overwritten.</p>
<p>In the past, carts used to have batteries installed, in order to support SRAM.  However, this
increases the cost of manufacturing.</p>
<p>As of writing, carts are now manufactured without batteries.  Typically SRAM is available, but
contents won't persist after power off (so it acts as an 8-bit RAM).</p>
<p>So how can a game developer make a game that saves player progress?</p>
<p>By using the same technique that the flashers use - writing data to the ROM itself.</p>
<h2 id="hardware-used-in-carts"><a class="header" href="#hardware-used-in-carts">Hardware Used in Carts</a></h2>
<p><img src="images/chips.jpg" alt="Cart Chips" /></p>
<p>In order to flash data to the cart, you will need to know what chips are in the cart.</p>
<p>For this guide, I will assume the cart is using a <code>S29GL128N</code> chip.  You can usually read the chip
by using a magnifying glass and looking at the text stamped on the chip.</p>
<p>If you are interested in the exact specifications of the chip, you will need to track down the data
sheet for it.  <a href="https://github.com/velipso/gvasm/blob/main/mirror/s29glxxxn.pdf">Here is the data sheet for the
S29GL128N</a>.  It will tell you
exactly how to communicate with the chip.</p>
<p>Thankfully, many different chips use the same protocols, so a save routine won't need to know the
exact chip, but instead just a category of chips.</p>
<p>At a high level, flashing to the cart will consist of:</p>
<ol>
<li>Querying the cart for sector layout</li>
<li>Erasing a sector</li>
<li>Writing the data to the sector</li>
</ol>
<p>This is accomplished by writing special values to the ROM, at special address locations.</p>
<h2 id="swapping-of-d0d1"><a class="header" href="#swapping-of-d0d1">Swapping of D0/D1</a></h2>
<p><strong>IMPORTANT NOTE:</strong> Many carts will swap the D0 and D1 lines!</p>
<p>This means when the specification says you need to write <code>0x55</code>, then you actually need to write
<code>0x56</code> because bits 0 and 1 are swapped (<code>01010101</code> -&gt; <code>01010110</code>).</p>
<p>This also affects reading the sector layout, because the values you read will have bits 0 and 1
swapped as well.</p>
<p>This <em>does not</em> affect the data written to the ROM.  If you want <code>0x4321</code> written to memory, then
just write <code>0x4321</code>, because it will be swapped on write, and swapped again on read, cancelling it
out.</p>
<h2 id="understanding-commands"><a class="header" href="#understanding-commands">Understanding Commands</a></h2>
<p>The table on page 57 shows the different commands available for the <code>S29GL128N</code>:</p>
<p><img src="images/commands.png" alt="S29GL128N Commands" /></p>
<p>You can see that this information also exists in the FlashGBX source code, <a href="https://github.com/lesserkuma/FlashGBX/blob/9b44a9959bf9fd6bab5f1005ce1c757d2f456fa7/FlashGBX/config/fc_AGB_MSP55LV128M.txt">in the
config</a>:</p>
<pre><code class="language-javascript">"reset":[
  [ 0, 0xF0 ]
],
"read_identifier":[
  [ 0xAAA, 0xA9 ],
  [ 0x555, 0x56 ],
  [ 0xAAA, 0x90 ]
],
"read_cfi":[
  [ 0xAA, 0x98 ]
],
...
</code></pre>
<p>Notice that the "Auto-Select" row doesn't exactly match the <code>"read_identifier"</code> information.</p>
<p>Auto-Select starts with address <code>0xAAA</code>, data <code>0xAA</code>, but FlashGBX has address <code>0xAAA</code>, data
<code>0xA9</code> -- this is because D0/D1 are swapped (<code>10101010</code> -&gt; <code>10101001</code>)!  <a href="#swapping-of-d0d1">See the section
above</a>.</p>
<p>So if we want to perform a reset on the chip, we just write <code>0xF0</code> to any address.  Note that reset
doesn't <em>erase</em> the chip, it just resets any commands in progress.</p>
<pre><code class="language-c">// reset
*((u16 *)0x08000000) = 0xF0;
__asm("nop");
</code></pre>
<p>The forked goombacolor project from LesserKuma has example code, where <a href="https://github.com/lesserkuma/goombacolor/blob/f2bae8eb5087de14008250032c82cf5d294131cd/src/main.c#L585">you can see this
happen</a>:</p>
<pre><code class="language-c">#define _FLASH_WRITE(pa, pd) { *(((u16 *)AGB_ROM)+((pa)/2)) = pd; __asm("nop"); }

// reset
_FLASH_WRITE(0, 0xF0);
// auto-select
_FLASH_WRITE(0xAAA, 0xA9);
_FLASH_WRITE(0x555, 0x56);
_FLASH_WRITE(0xAAA, 0x90);
</code></pre>
<p><strong>IMPORTANT NOTE:</strong> Since we need to control the reads/writes sent to the ROM, we cannot run the
code from the ROM.  You will need to <a href="https://github.com/lesserkuma/goombacolor/blob/f2bae8eb5087de14008250032c82cf5d294131cd/src/main.c#L553">load the code into
EWRAM</a>
or IWRAM so that the bus between the GBA and the cart doesn't have extra reads to execute code.</p>
<h2 id="querying-for-information"><a class="header" href="#querying-for-information">Querying for Information</a></h2>
<p>There is a standard protocol used by all flash chips called the <a href="https://en.wikipedia.org/wiki/Common_Flash_Memory_Interface">Common Flash Memory
Interface</a> (CFI).</p>
<p>You can use CFI to query a lot of information about the chip you're interacting with.  The chip
specifications should have a section on CFI.</p>
<p>Two things in particular you probably want is whether D0/D1 are swapped, and the region layout.</p>
<h2 id="detecting-if-d0d1-are-swapped"><a class="header" href="#detecting-if-d0d1-are-swapped">Detecting if D0/D1 are Swapped</a></h2>
<p>You can detect if D0/D1 are swapped by putting the chip in CFI mode, then reading the bytes at
<code>0x20</code>, <code>0x22</code>, and <code>0x24</code>.  These values are hardcoded to <code>'Q'</code>, <code>'R'</code>, <code>'Y'</code>, but if D0/D1 are
swapped, you'll instead see <code>'R'</code>, <code>'Q'</code>, <code>'Z'</code>.</p>
<p>Here is some example code:</p>
<pre><code class="language-c">// reset the chip
_FLASH_WRITE(0, 0xF0);
// enter CFI mode
_FLASH_WRITE(0xAA, 0x98);

// read the header
u16 Q = *(((u16 *)AGB_ROM)+(0x20/2));
u16 R = *(((u16 *)AGB_ROM)+(0x22/2));
u16 Y = *(((u16 *)AGB_ROM)+(0x24/2));
bool swapBits = false;

if (Q == 'Q' &amp;&amp; R == 'R' &amp;&amp; Y == 'Y') {
  // CFI mode is enabled, D0/D1 are not swapped
  swapBits = false;
}
else if (Q == 'R' &amp;&amp; R == 'Q' &amp;&amp; Y == 'Z') {
  // CFI mode is enabled, D0/D1 are swapped
  swapBits = true;
}
else {
  // chip didn't enter CFI mode, try something else
}
</code></pre>
<p>Once you know if D0/D1 are swapped, you can write a helper function for reading bytes from the ROM:</p>
<pre><code class="language-c">u8 readByte(int addr, bool swapBits) {
  u8 data = *(((u16 *)AGB_ROM)+(addr/2));
  if (swapBits) {
    data =
      (data &amp; 0xfc) |
      ((data &amp; 1) &lt;&lt; 1) |
      ((data &amp; 2) &gt;&gt; 1);
  }
  return data;
}
</code></pre>
<h2 id="understanding-region-layout"><a class="header" href="#understanding-region-layout">Understanding Region Layout</a></h2>
<p>The region layout is useful for calculating where the sectors start, and how large they are.
Assuming you want to overwrite sectors at the end of the ROM, you need to figure out what
address(es) to write to.</p>
<p>There are 1-4 regions, and each region has a sector count and sector size.</p>
<p>After entering CFI mode, you can read the region layout from memory:</p>
<p><img src="images/regions.png" alt="Region Layout Memory Locations" /></p>
<p>Here's some example code:</p>
<pre><code class="language-c">// assuming we are already in CFI mode
int regionCount = readByte(0x58, swapBits);
struct {
  int sectorCount;
  int sectorSize;
} regions[4] = {0};

for (int region = 0; region &lt; regionCount; region++) {
  int sectorCountLow  = readByte(0x5A + region * 8, swapBits);
  int sectorCountHigh = readByte(0x5C + region * 8, swapBits);
  int sectorSizeLow   = readByte(0x5E + region * 8, swapBits);
  int sectorSizeHigh  = readByte(0x60 + region * 8, swapBits);

  // note we must add one!
  regions[region].sectorCount =
    ((sectorCountHigh &lt;&lt; 8) | sectorCountLow) + 1;

  // note we must multiply by 256!
  regions[region].sectorSize =
    ((sectorSizeHigh &lt;&lt; 8) | sectorSizeLow) &lt;&lt; 8;
}
</code></pre>
<h2 id="erasing-a-sector"><a class="header" href="#erasing-a-sector">Erasing a Sector</a></h2>
<p>Erasing a sector will set all the values in that sector to <code>0xFFFF</code>.</p>
<p>This is fairly straight forward, you can use
<a href="https://github.com/lesserkuma/goombacolor/blob/f2bae8eb5087de14008250032c82cf5d294131cd/src/main.c#L657">goombacolor</a>
as a reference:</p>
<pre><code class="language-c">// Erase flash sector
_FLASH_WRITE(sa, 0xF0);
_FLASH_WRITE(0xAAA, 0xA9);
_FLASH_WRITE(0x555, 0x56);
_FLASH_WRITE(0xAAA, 0x80);
_FLASH_WRITE(0xAAA, 0xA9);
_FLASH_WRITE(0x555, 0x56);
_FLASH_WRITE(sa, 0x30);
while (1) {
  __asm("nop");
  if (*(((u16 *)AGB_ROM)+(sa/2)) == 0xFFFF) {
    break;
  }
}
_FLASH_WRITE(sa, 0xF0);
</code></pre>
<p>You now should be able to understand this code.</p>
<p>This sequence of writes matches the documentation (with D0/D1 swapped).</p>
<p>The variable <code>sa</code> is the sector address.  The code:</p>
<ol>
<li>Resets the chip</li>
<li>Erases the sector</li>
<li>Waits in a loop until it reads <code>0xFFFF</code> from the sector, indicating the erase is finished</li>
<li>Resets the chip again</li>
</ol>
<h2 id="saving-data"><a class="header" href="#saving-data">Saving Data</a></h2>
<p>Once again, <a href="https://github.com/lesserkuma/goombacolor/blob/f2bae8eb5087de14008250032c82cf5d294131cd/src/main.c#L673">goombacolor</a>
is a great reference:</p>
<pre><code class="language-c">for (int i=0; i&lt;AGB_SRAM_SIZE; i+=2) {
  _FLASH_WRITE(0xAAA, 0xA9);
  _FLASH_WRITE(0x555, 0x56);
  _FLASH_WRITE(0xAAA, 0xA0);
  _FLASH_WRITE(sa+i, (*(u8 *)(AGB_SRAM+i+1)) &lt;&lt; 8 | (*(u8 *)(AGB_SRAM+i)));
  while (1) {
    __asm("nop");
    if (*(((u16 *)AGB_ROM)+((sa+i)/2)) == ((*(u8 *)(AGB_SRAM+i+1)) &lt;&lt; 8 | (*(u8 *)(AGB_SRAM+i)))) {
      break;
    }
  }
}
_FLASH_WRITE(sa, 0xF0);
</code></pre>
<p>The code:</p>
<ol>
<li>Issues a "Program" command for each 16-bit value</li>
<li>Writes the 16-bit value at the target address</li>
<li>Waits in a loop until it reads the written value*</li>
<li>Continues writing until all 16-bit values are written</li>
<li>Resets the chip</li>
</ol>
<p>Note that this code copies data from SRAM into the ROM.  As a homebrew developer, you don't <em>have</em>
to do it this way -- you can just write directly to the ROM.  However, you should still have code
that saves to SRAM so that emulators can save the data.</p>
<p>* You might think this loop could be incorrect if by chance, the read returns the value written
before it was actually finished.  See the section on DQ7 Data Polling on page 59 to understand why
this won't happen.  In summary, DQ7 will always be the opposite of whatever was written until the
write goes through.</p>
<h2 id="final-thoughts"><a class="header" href="#final-thoughts">Final Thoughts</a></h2>
<p>This guide is a starting point, but it cannot replace experimentation.  Now that you understand the
basic idea, here are some things you will want to consider:</p>
<ol>
<li>If a user shuts off power during a save, then the save will be incomplete.  You can backup the
save into another sector to ensure the data will always be recoverable.</li>
<li>If you want your game to work on emulators, you will still need to save to SRAM.  However, if you
don't care about emulators, then you can have much larger save files (for example, reserving 8 MB
for game code, 4 MB for save data, and 4 MB for backup).</li>
<li>Different chips have different commands, so if you want to support multiple chips, you will need
a method to detect which chip you're on, and use the appropriate commands.
<a href="https://github.com/lesserkuma/FlashGBX/blob/master/FlashGBX/hw_GBxCartRW.py#L1469">FlashGBX</a> and
<a href="https://github.com/lesserkuma/goombacolor/blob/main/src/main.c#L554">goombacolor</a>
are great references for this, and they both use different methods.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../fixed-point-math.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../ack.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../fixed-point-math.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../ack.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
